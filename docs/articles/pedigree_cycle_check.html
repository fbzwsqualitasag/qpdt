<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Check for Cycles in Pedigrees • qpdt</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Check for Cycles in Pedigrees">
<meta property="og:description" content="qpdt">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">qpdt</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/gs_pedigree_check.html">Checking Consistency of Animal Pedigrees</a>
    </li>
    <li>
      <a href="../articles/pedigree_check_report.html">Report Pedigree Checks</a>
    </li>
    <li>
      <a href="../articles/pedigree_cycle_check.html">Check for Cycles in Pedigrees</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/fbzwsqualitasag/qpdt/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="pedigree_cycle_check_files/header-attrs-2.7/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Check for Cycles in Pedigrees</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/fbzwsqualitasag/qpdt/blob/master/vignettes/pedigree_cycle_check.Rmd"><code>vignettes/pedigree_cycle_check.Rmd</code></a></small>
      <div class="hidden name"><code>pedigree_cycle_check.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">qpdt</span>)</pre></body></html></div>
<div id="disclaimer" class="section level1">
<h1 class="hasAnchor">
<a href="#disclaimer" class="anchor"></a>Disclaimer</h1>
<p>From a graph theoretic point of view, a pedigree can be represented as a directed acyclic graph. The name already tells it, that the graph must not show any cycles.</p>
</div>
<div id="terminology" class="section level1">
<h1 class="hasAnchor">
<a href="#terminology" class="anchor"></a>Terminology</h1>
<div id="graph" class="section level2">
<h2 class="hasAnchor">
<a href="#graph" class="anchor"></a>Graph</h2>
<p>In general a <strong>graph</strong> <span class="math inline">\(G = (V, E)\)</span> is defined by the two sets <span class="math inline">\(V\)</span> and <span class="math inline">\(E\)</span> where <span class="math inline">\(V\)</span> contains the set of vertices or nodes and <span class="math inline">\(E\)</span> contains the set of edges where each edge is formed by two verties. Two main categories of graphs exist.</p>
<ol style="list-style-type: decimal">
<li>undirected graphs: edges do not show any directions, hence the order of the two vertices forming an edge is not important.</li>
<li>directed graphs: edges have a directions and with that the order of the vertices that define an edge is important.</li>
</ol>
<p>When graphs are shown as diagrams, edges of directed graphs are symbolised by arrows and edges of undirected graphs are just shown as ordinary lines.</p>
<p>In a directed graph, the number of edges which “point to” a given vertex, corresponds to the <strong>in-degree</strong> of the respective vertex. A certain edge <span class="math inline">\(E_j\)</span> “points to” a vertex <span class="math inline">\(V_i\)</span>, if vertex <span class="math inline">\(V_i\)</span> is the second element of edge <span class="math inline">\(E_j\)</span>, hence <span class="math inline">\(E_j = (*, V_i)\)</span>. Analogously, the number of edges which “point away” from a given vertex, defines the <strong>out-degree</strong> of the vertex. If edge <span class="math inline">\(E_j\)</span> points away from vertex <span class="math inline">\(V_i\)</span>, then <span class="math inline">\(E_j = (V_i, *)\)</span>.</p>
<p>Vertex <span class="math inline">\(V_i\)</span> is called a <strong>root vertex</strong> (or root node), if the in-degree of <span class="math inline">\(V_i\)</span> is equal to <span class="math inline">\(0\)</span>. Vertex <span class="math inline">\(V_i\)</span> is referred to as <strong>terminal vertex</strong> if the out-degree of <span class="math inline">\(V_i\)</span> is equal to <span class="math inline">\(0\)</span>.</p>
</div>
<div id="pedigree" class="section level2">
<h2 class="hasAnchor">
<a href="#pedigree" class="anchor"></a>Pedigree</h2>
<p>Pedigrees can be represented by directed graphs. The nodes stand for the individuals in the pedigree and the edges show the relationship between parents and offspring. The direction is often chosen to go from parents to offspring. Further properties of a pedigree-graph are that</p>
<ul>
<li>the in-degree (number of arrows pointing to a certain vertex) is always two.</li>
<li>a pedigree-graph cannot contain any cycles due to the time-lag of the parent generation to the offspring generations.</li>
</ul>
</div>
<div id="cycle" class="section level2">
<h2 class="hasAnchor">
<a href="#cycle" class="anchor"></a>Cycle</h2>
<p>A cycle in a directed graph is found when in a path of vertices along the directed edges, any vertice is visited more than once.</p>
<div class="sourceCode" id="cb2"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">Rgraphviz</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">new</span>(<span class="st">"graphNEL"</span>, <span class="kw">nodes</span><span class="kw">=</span><span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span>(<span class="fl">1</span>:<span class="fl">6</span>), <span class="kw">edgemode</span><span class="kw">=</span><span class="st">"directed"</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"1"</span>, <span class="st">"2"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"1"</span>, <span class="st">"3"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"2"</span>, <span class="st">"3"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"4"</span>, <span class="st">"1"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"4"</span>, <span class="st">"5"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"5"</span>, <span class="st">"6"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="no">dg_cyc</span> <span class="kw">&lt;-</span> <span class="fu">addEdge</span>(<span class="st">"6"</span>, <span class="st">"4"</span>, <span class="no">dg_cyc</span>, <span class="fl">1</span>)
<span class="fu"><a href="https://rdrr.io/r/base/plot.html">plot</a></span>(<span class="no">dg_cyc</span>)</pre></body></html></div>
<p><img src="pedigree_cycle_check_files/figure-html/show-directed-graph-1.png" width="700"></p>
<p>Starting at node <span class="math inline">\(4\)</span> and following the path along the directed edges leads to the following path</p>
<p><span class="math display">\[4 \rightarrow 5 \rightarrow 6 \rightarrow 4.\]</span></p>
<p>The above path visits the vertex <span class="math inline">\(4\)</span> twice and hence the above directed graph contains a cycle.</p>
<p>Directed graphs that do not contain any cycles are called <strong>directed acyclic graphs</strong> (DAG). This special class of directed acyclic graphs is of special interest because the representation of a pedigree in terms of graphs corresponds to a DAG. As a consequence of that any graph that represents a pedigree cannot contain any cycles and this property can be used as a consistency check for a pedigree.</p>
</div>
</div>
<div id="algorithm" class="section level1">
<h1 class="hasAnchor">
<a href="#algorithm" class="anchor"></a>Algorithm</h1>
<p>As explained in the previous section, any pedigree can be represented by a DAG. Hence, we can construct a directed graph based on a given pedigree and then we can check whether this graph contains any cycles. In order to perform this check, we need an algorithm that takes a directed graph as input and that outputs the result ‘TRUE’, if the directed graph that was used as input contains any cycles and ‘FALSE’ otherwise. Only pedigrees whose directed graph representations cause the algorithm to return the result ‘FALSE’ are valid pedigrees.</p>
<p>The idea of an algorithm to find cycles in a directed graph is based on the concept of ‘depth-first’ traversal (DFT) of the graph. In a depth first traversal of a graph, the vertices are visited recursively along the parent-offspring relationship until a dead-end is hit with a vertex that does not have anymore offspring. Once a dead-end is hit, the traversal does a back-track to the parent with more offpsring that have not yet been visited.</p>
<p>A ‘depth-first’ traversal of the above shown example graph starting at vertex <span class="math inline">\(1\)</span> would lead to the following path</p>
<p><span class="math display">\[1 \rightarrow 2 \rightarrow 3 \rightarrow 3\]</span></p>
</div>
<div id="first-implementation" class="section level1">
<h1 class="hasAnchor">
<a href="#first-implementation" class="anchor"></a>First Implementation</h1>
<p>The first implementation is done using three different sets of vertices.</p>
<ol style="list-style-type: decimal">
<li>white set: contains all vertices that have not been visited by a DFT</li>
<li>grey set: vertices that have been visited by the current DFT starting at a given vertex</li>
<li>black set: vertices that have been visited by previous rounds of DFT</li>
</ol>
<p>The implementation consists of the following steps</p>
<ul>
<li>Step 1: Initialisation by moving all vertices into the white set</li>
<li>Step 2: Select any of the vertices from the white set and move it to the grey set.</li>
<li>Step 3: Run a DFT from the selected vertex</li>
<li>Step 4: In the forward phase of the DFT move the visited vertices to the grey set, if a vertex that should be added to the grey set is already in the grey set, then we have found a cycle and we return the answer ‘YES’.</li>
<li>Step 5: In the backtracking phase of the DFT, the vertices are moved from the white set to the black set.</li>
<li>Step 6: Go back to Step 2 and select a different vertex, return ‘FALSE’ if the white set is empty</li>
</ul>
<div id="r-code" class="section level2">
<h2 class="hasAnchor">
<a href="#r-code" class="anchor"></a>R-code</h2>
<p>In this subsection, we try to give some R-code to solve the problem of finding cycles in directed graphs for the above example. Before starting with the steps of the implementation, we have to define the graph. In this case, we use an adjacency matrix <span class="math inline">\(A\)</span>.</p>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="co"># number of vertices in the graph</span>
<span class="no">nr_vert</span> <span class="kw">&lt;-</span> <span class="fl">6</span>
<span class="co"># adjacency matrix</span>
<span class="no">mat_A</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="fl">0</span>, <span class="kw">nrow</span> <span class="kw">=</span> <span class="no">nr_vert</span>, <span class="kw">ncol</span> <span class="kw">=</span> <span class="no">nr_vert</span>)
<span class="no">mat_A</span>[<span class="fl">1</span>, <span class="fl">2</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>[<span class="fl">1</span>, <span class="fl">3</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>[<span class="fl">2</span>, <span class="fl">3</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>[<span class="fl">4</span>, <span class="fl">1</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>[<span class="fl">4</span>, <span class="fl">5</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>[<span class="fl">5</span>, <span class="fl">6</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>[<span class="fl">6</span>, <span class="fl">4</span>] <span class="kw">&lt;-</span> <span class="fl">1</span>
<span class="no">mat_A</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]</span>
<span class="co">#&gt; [1,]    0    1    1    0    0    0</span>
<span class="co">#&gt; [2,]    0    0    1    0    0    0</span>
<span class="co">#&gt; [3,]    0    0    0    0    0    0</span>
<span class="co">#&gt; [4,]    1    0    0    0    1    0</span>
<span class="co">#&gt; [5,]    0    0    0    0    0    1</span>
<span class="co">#&gt; [6,]    0    0    0    1    0    0</span></pre></body></html></div>
<p>We start with step 1, the initialisation of the three sets</p>
<div class="sourceCode" id="cb4"><html><body><pre class="r"><span class="co"># initialisation</span>
(<span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">white</span> <span class="kw">=</span> <span class="fl">1</span>:<span class="fl">6</span>,
              <span class="kw">grey</span> <span class="kw">=</span> <span class="kw">NULL</span>,
              <span class="kw">black</span> <span class="kw">=</span> <span class="kw">NULL</span>))
<span class="co">#&gt; $white</span>
<span class="co">#&gt; [1] 1 2 3 4 5 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $grey</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $black</span>
<span class="co">#&gt; NULL</span></pre></body></html></div>
<p>In step 2, a random vertex, e.g. vertex <span class="math inline">\(1\)</span> is selected and moved from the white set to the grey set. Because the move of vertices from the white set to the grey set is a task that has to be done repeatedly, we are creating a function for that.</p>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="no">move_white_grey</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pn_cur_vertex</span>, <span class="no">pl_set</span>){
  <span class="co"># if pn_cur_vertex is already in the grey set, then we found a cycle</span>
  <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">pn_cur_vertex</span>, <span class="no">pl_set</span>$<span class="no">grey</span>))
    <span class="fu"><a href="https://rdrr.io/r/base/stop.html">stop</a></span>(<span class="st">" * Found a cycle in the graph with vertex: "</span>, <span class="no">pn_cur_vertex</span>)
  <span class="co"># init result set</span>
  <span class="no">l_result_set</span> <span class="kw">&lt;-</span> <span class="no">pl_set</span>
  <span class="co"># check whether current vertex is in the white set</span>
  <span class="kw">if</span> (!<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">pn_cur_vertex</span>, <span class="no">l_result_set</span>$<span class="no">white</span>))
    <span class="fu"><a href="https://rdrr.io/r/base/stop.html">stop</a></span>(<span class="st">" *** ERROR: CANNOT FIND vertex: "</span>, <span class="no">pn_cur_vertex</span>, <span class="st">" in white set: "</span>, <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span>(<span class="no">l_result_set</span>$<span class="no">white</span>, <span class="kw">collapse</span> <span class="kw">=</span> <span class="st">','</span>))
  <span class="co"># remove pn_cur_vertex from white set</span>
  <span class="no">l_result_set</span>$<span class="no">white</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sets.html">setdiff</a></span>(<span class="no">l_result_set</span>$<span class="no">white</span>, <span class="no">pn_cur_vertex</span>)
  <span class="co"># add pn_cur_vertex to grey set</span>
  <span class="no">l_result_set</span>$<span class="no">grey</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sets.html">union</a></span>(<span class="no">l_result_set</span>$<span class="no">grey</span>, <span class="no">pn_cur_vertex</span>)
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="no">l_result_set</span>)
}</pre></body></html></div>
<p>The move can be done with</p>
<div class="sourceCode" id="cb6"><html><body><pre class="r"><span class="no">cur_vertex</span> <span class="kw">&lt;-</span> <span class="fl">1</span>
(<span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_white_grey</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">cur_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>))
<span class="co">#&gt; $white</span>
<span class="co">#&gt; [1] 2 3 4 5 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $grey</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $black</span>
<span class="co">#&gt; NULL</span></pre></body></html></div>
<p>Now we have to explore all neighbors of vertex <span class="math inline">\(1\)</span>. The neighbors are found in the first row of the adjacency matrix <span class="math inline">\(A\)</span></p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span>(<span class="no">mat_A</span>[<span class="no">cur_vertex</span>,] <span class="kw">==</span> <span class="fl">1</span>)
<span class="co">#&gt; [1] 2 3</span></pre></body></html></div>
<p>The neighbors are found in the columns where the matrix <span class="math inline">\(A\)</span> has an entry of <span class="math inline">\(1\)</span>. The neighbors of a given vertex can be obtained with the following function</p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="no">get_neighbors</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pn_cur_vertex</span>, <span class="no">pmat_adj</span>){
  <span class="co"># check whether the index of the current vertex is in adj matrix</span>
  <span class="kw">if</span> (<span class="no">pn_cur_vertex</span> <span class="kw">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="no">pmat_adj</span>))
    <span class="fu"><a href="https://rdrr.io/r/base/stop.html">stop</a></span>(<span class="st">" *** ERROR: CANNOT FIND current vertex: "</span>, <span class="no">pn_cur_vertex</span>)
  <span class="co"># get neighbors</span>
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span>(<span class="no">pmat_adj</span>[<span class="no">pn_cur_vertex</span>, ] <span class="kw">==</span> <span class="fl">1</span>))
}</pre></body></html></div>
<p>The above function to return neighbors of all vertices can be tested with</p>
<div class="sourceCode" id="cb9"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span>(<span class="fl">1</span>:<span class="no">nr_vert</span>, <span class="no">get_neighbors</span>, <span class="no">mat_A</span>)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 2 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; integer(0)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 1 5</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; [1] 4</span></pre></body></html></div>
<p>Now we assign the first neighbor of <span class="math inline">\(1\)</span> as the current vertex which is</p>
<div class="sourceCode" id="cb10"><html><body><pre class="r">(<span class="no">vec_neighbors_v1</span> <span class="kw">&lt;-</span> <span class="fu">get_neighbors</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">cur_vertex</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">mat_A</span>))
<span class="co">#&gt; [1] 2 3</span></pre></body></html></div>
<p>Hence the new current vertex is</p>
<div class="sourceCode" id="cb11"><html><body><pre class="r">(<span class="no">cur_vertex</span> <span class="kw">&lt;-</span> <span class="no">vec_neighbors_v1</span>[<span class="fl">1</span>])
<span class="co">#&gt; [1] 2</span></pre></body></html></div>
<p>We have to check whether the current vertex <span class="math inline">\(2\)</span> is in the black set or in the grey set</p>
<div class="sourceCode" id="cb12"><html><body><pre class="r">(<span class="no">b_check</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">cur_vertex</span>, <span class="no">l_set</span>$<span class="no">black</span>) <span class="kw">||</span> <span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">cur_vertex</span>, <span class="no">l_set</span>$<span class="no">grey</span>))
<span class="co">#&gt; [1] FALSE</span></pre></body></html></div>
<p>which is FALSE. Hence we can add the current vertex to the grey set.</p>
<div class="sourceCode" id="cb13"><html><body><pre class="r">(<span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_white_grey</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">cur_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>))
<span class="co">#&gt; $white</span>
<span class="co">#&gt; [1] 3 4 5 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $grey</span>
<span class="co">#&gt; [1] 1 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $black</span>
<span class="co">#&gt; NULL</span></pre></body></html></div>
<p>Since we are doing a DFT, we have to first check for neighbors of the current vertex <span class="math inline">\(2\)</span>. The neighbors are obtained by</p>
<div class="sourceCode" id="cb14"><html><body><pre class="r">(<span class="no">vec_neighbors_v2</span> <span class="kw">&lt;-</span> <span class="fu">get_neighbors</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">cur_vertex</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">mat_A</span>))
<span class="co">#&gt; [1] 3</span></pre></body></html></div>
<p>The current vertex is assigned to</p>
<div class="sourceCode" id="cb15"><html><body><pre class="r">(<span class="no">cur_vertex</span> <span class="kw">&lt;-</span> <span class="no">vec_neighbors_v2</span>[<span class="fl">1</span>])
<span class="co">#&gt; [1] 3</span></pre></body></html></div>
<p>Because the current vertex <span class="math inline">\(3\)</span> is neither in the grey set nor in the black set, it is added to the grey set,</p>
<div class="sourceCode" id="cb16"><html><body><pre class="r">(<span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_white_grey</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">cur_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>))
<span class="co">#&gt; $white</span>
<span class="co">#&gt; [1] 4 5 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $grey</span>
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $black</span>
<span class="co">#&gt; NULL</span></pre></body></html></div>
<p>Because the current vertex <span class="math inline">\(3\)</span> does not have any neighbors, all vertices in the grey set are moved to the black set.</p>
<div class="sourceCode" id="cb17"><html><body><pre class="r"><span class="no">move_grey_black</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pn_current_vertex</span>, <span class="no">pl_set</span>){
  <span class="co"># check whether pn_current_vertex is already in the black set</span>
  <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">pn_current_vertex</span>, <span class="no">pl_set</span>$<span class="no">black</span>))
    <span class="fu"><a href="https://rdrr.io/r/base/stop.html">stop</a></span>(<span class="st">" *** ERROR: FOUND vertex: "</span>, <span class="no">pn_current_vertex</span>, <span class="st">" in black set: "</span>, <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span>(<span class="no">pl_set</span>$<span class="no">black</span>, <span class="kw">collapse</span> <span class="kw">=</span> <span class="st">', '</span>))
  <span class="no">l_result_set</span> <span class="kw">&lt;-</span> <span class="no">pl_set</span>
  <span class="no">l_result_set</span>$<span class="no">grey</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sets.html">setdiff</a></span>(<span class="no">l_result_set</span>$<span class="no">grey</span>, <span class="no">pn_current_vertex</span>)
  <span class="no">l_result_set</span>$<span class="no">black</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sets.html">union</a></span>( <span class="no">l_result_set</span>$<span class="no">black</span>, <span class="no">pn_current_vertex</span>)
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="no">l_result_set</span>)
}</pre></body></html></div>
<p>Applying the function for all elements in the grey set leads to</p>
<div class="sourceCode" id="cb18"><html><body><pre class="r"><span class="no">vec_visited_vertex</span> <span class="kw">&lt;-</span> <span class="no">l_set</span>$<span class="no">grey</span>
<span class="kw">for</span> (<span class="no">v</span> <span class="kw">in</span> <span class="no">vec_visited_vertex</span>){
   <span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_grey_black</span>(<span class="kw">pn_current_vertex</span> <span class="kw">=</span> <span class="no">v</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>)
}
<span class="no">l_set</span>
<span class="co">#&gt; $white</span>
<span class="co">#&gt; [1] 4 5 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $grey</span>
<span class="co">#&gt; numeric(0)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $black</span>
<span class="co">#&gt; [1] 1 2 3</span></pre></body></html></div>
<p>At this point, the DFT is returning to the second neighbor of vertex <span class="math inline">\(1\)</span> which corresponds to 3. Since this neighbor is already in the black set, we do not have to check 3 again.</p>
<p>The next step is to go back to the remaining elements in the white set. The remaining steps are done using the following set of functions.</p>
</div>
<div id="dft-functions" class="section level2">
<h2 class="hasAnchor">
<a href="#dft-functions" class="anchor"></a>DFT Functions</h2>
<p>The following functions can be used to automate the checks and the DFT.</p>
<div class="sourceCode" id="cb19"><html><body><pre class="r"><span class="no">has_cycle</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pmat_adj</span>){
  <span class="no">nr_vertex</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="no">pmat_adj</span>)
  <span class="co"># check whether pmat_adj is quadratic</span>
  <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span>(<span class="no">pmat_adj</span>) <span class="kw">!=</span> <span class="no">nr_vertex</span>)
    <span class="fu"><a href="https://rdrr.io/r/base/stop.html">stop</a></span>(<span class="st">" *** ERROR: pmat_adj is not a valid adjacency matrix"</span>)
  <span class="co"># define the sets</span>
  <span class="no">l_set_wgb</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">white</span> <span class="kw">=</span> <span class="fl">1</span>:<span class="no">nr_vertex</span>,
                    <span class="kw">grey</span>  <span class="kw">=</span> <span class="kw">NULL</span>,
                    <span class="kw">black</span> <span class="kw">=</span> <span class="kw">NULL</span>)
  <span class="co"># loop over vertices in the white set</span>
  <span class="no">vec_non_visited</span> <span class="kw">&lt;-</span> <span class="no">l_set_wgb</span>$<span class="no">white</span>
  <span class="kw">for</span> (<span class="no">v</span> <span class="kw">in</span> <span class="no">vec_non_visited</span>){
    <span class="kw">if</span> (<span class="fu">dfs</span>(<span class="kw">pn_current_vertex</span> <span class="kw">=</span> <span class="no">v</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set_wgb</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">pmat_adj</span>))
      <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">TRUE</span>)
  }
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">FALSE</span>)
}</pre></body></html></div>
<p>The recursive DFT is done in the function <code>dfs()</code></p>
<div class="sourceCode" id="cb20"><html><body><pre class="r"><span class="no">dfs</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pn_current_vertex</span>, <span class="no">pl_set</span>,  <span class="no">pmat_adj</span>){
  <span class="co"># move the current vertex to the grey set</span>
  <span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_white_grey</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">pn_current_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">pl_set</span>)
  <span class="co"># determine neighbors of the current vertex</span>
  <span class="no">vec_neighbors</span> <span class="kw">&lt;-</span> <span class="fu">get_neighbors</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">pn_current_vertex</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">pmat_adj</span>)
  <span class="co"># loop over neighbors</span>
  <span class="kw">for</span> (<span class="no">idx</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_along</a></span>(<span class="no">vec_neighbors</span>)){
    <span class="no">cur_neighbor</span> <span class="kw">&lt;-</span> <span class="no">vec_neighbors</span>[<span class="no">idx</span>]
    <span class="co"># if the current neighbor is in the black set, continue</span>
    <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">cur_neighbor</span>, <span class="no">l_set</span>$<span class="no">black</span>))
      <span class="kw">next</span>
    <span class="co"># if the neighbor is in the grey set, cylce is found</span>
    <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">cur_neighbor</span>, <span class="no">l_set</span>$<span class="no">grey</span>))
      <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">TRUE</span>)
    <span class="co"># continue DFT with neighbor</span>
    <span class="kw">if</span> (<span class="fu">dfs</span>(<span class="kw">pn_current_vertex</span> <span class="kw">=</span> <span class="no">cur_neighbor</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">pmat_adj</span>))
      <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">TRUE</span>)
  }
  <span class="co"># move the current vertex from grey to black</span>
  <span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_grey_black</span>(<span class="kw">pn_current_vertex</span> <span class="kw">=</span> <span class="no">pn_current_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>)
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">FALSE</span>)
}</pre></body></html></div>
<p>The above function can be tested with the following call</p>
<div class="sourceCode" id="cb21"><html><body><pre class="r"><span class="fu">has_cycle</span>(<span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">mat_A</span>)
<span class="co">#&gt; [1] TRUE</span></pre></body></html></div>
<p>This result shows that the directed graph represented by the adjacency matrix <code>mat_A</code> contains a cycle. If the edge between vertices <span class="math inline">\(6\)</span> and <span class="math inline">\(4\)</span> is removed, then we get a directed acyclic graph.</p>
<div class="sourceCode" id="cb22"><html><body><pre class="r"><span class="no">mat_A_dag</span> <span class="kw">&lt;-</span> <span class="no">mat_A</span>
<span class="no">mat_A_dag</span>[<span class="fl">6</span>,<span class="fl">4</span>] <span class="kw">&lt;-</span> <span class="fl">0</span>
<span class="no">mat_A_dag</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]</span>
<span class="co">#&gt; [1,]    0    1    1    0    0    0</span>
<span class="co">#&gt; [2,]    0    0    1    0    0    0</span>
<span class="co">#&gt; [3,]    0    0    0    0    0    0</span>
<span class="co">#&gt; [4,]    1    0    0    0    1    0</span>
<span class="co">#&gt; [5,]    0    0    0    0    0    1</span>
<span class="co">#&gt; [6,]    0    0    0    0    0    0</span></pre></body></html></div>
<p>Running the check for the DAG given by <code>mat_A_dag</code> results in</p>
<div class="sourceCode" id="cb23"><html><body><pre class="r"><span class="fu">has_cycle</span>(<span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">mat_A_dag</span>)
<span class="co">#&gt; [1] FALSE</span></pre></body></html></div>
</div>
</div>
<div id="optimisation" class="section level1">
<h1 class="hasAnchor">
<a href="#optimisation" class="anchor"></a>Optimisation</h1>
<p>As shown above, the algorithm was able to find cycles in the two example graphs. There are a number of improvements that can be made to the solution proposed so far.</p>
<ol style="list-style-type: decimal">
<li>Show the vertices that form the cycle. Besides the result indicating whether a directed graph contains any cycles or not, the list of vertices which form the cycle are of interest to the user.</li>
<li>Use a node-list instead of an adjacency matrix as input</li>
<li>Add only non-root and non-terminal vertices to the white set instead of adding all vertices to the white set</li>
</ol>
<div id="show-vertices-in-cycle" class="section level2">
<h2 class="hasAnchor">
<a href="#show-vertices-in-cycle" class="anchor"></a>Show Vertices in Cycle</h2>
<p>In a first approach we can modify the function <code>dfs()</code> to output the vertices in the cycle.</p>
<div class="sourceCode" id="cb24"><html><body><pre class="r"><span class="no">dfs</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pn_current_vertex</span>, <span class="no">pl_set</span>,  <span class="no">pmat_adj</span>){
  <span class="co"># move the current vertex to the grey set</span>
  <span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_white_grey</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">pn_current_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">pl_set</span>)
  <span class="co"># determine neighbors of the current vertex</span>
  <span class="no">vec_neighbors</span> <span class="kw">&lt;-</span> <span class="fu">get_neighbors</span>(<span class="kw">pn_cur_vertex</span> <span class="kw">=</span> <span class="no">pn_current_vertex</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">pmat_adj</span>)
  <span class="co"># loop over neighbors</span>
  <span class="kw">for</span> (<span class="no">idx</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_along</a></span>(<span class="no">vec_neighbors</span>)){
    <span class="no">cur_neighbor</span> <span class="kw">&lt;-</span> <span class="no">vec_neighbors</span>[<span class="no">idx</span>]
    <span class="co"># if the current neighbor is in the black set, continue</span>
    <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">cur_neighbor</span>, <span class="no">l_set</span>$<span class="no">black</span>))
      <span class="kw">next</span>
    <span class="co"># if the neighbor is in the grey set, cylce is found</span>
    <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">cur_neighbor</span>, <span class="no">l_set</span>$<span class="no">grey</span>)){
      <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span>(<span class="st">" * Cycle - current node: "</span>, <span class="no">cur_neighbor</span>, <span class="st">" - grey set: "</span>, <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span>(<span class="no">l_set</span>$<span class="no">grey</span>, <span class="kw">collapse</span> <span class="kw">=</span> <span class="st">', '</span>), <span class="st">"\n"</span>)
      <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">TRUE</span>)
    }
    <span class="co"># continue DFT with neighbor</span>
    <span class="kw">if</span> (<span class="fu">dfs</span>(<span class="kw">pn_current_vertex</span> <span class="kw">=</span> <span class="no">cur_neighbor</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>, <span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">pmat_adj</span>))
      <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">TRUE</span>)
  }
  <span class="co"># move the current vertex from grey to black</span>
  <span class="no">l_set</span> <span class="kw">&lt;-</span> <span class="fu">move_grey_black</span>(<span class="kw">pn_current_vertex</span> <span class="kw">=</span> <span class="no">pn_current_vertex</span>, <span class="kw">pl_set</span> <span class="kw">=</span> <span class="no">l_set</span>)
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="fl">FALSE</span>)
}</pre></body></html></div>
<p>Calling the check function for the graph containing the cycle results in</p>
<div class="sourceCode" id="cb25"><html><body><pre class="r"><span class="fu">has_cycle</span>(<span class="kw">pmat_adj</span> <span class="kw">=</span> <span class="no">mat_A</span>)
<span class="co">#&gt;  * Cycle - current node:  4  - grey set:  4, 5, 6</span>
<span class="co">#&gt; [1] TRUE</span></pre></body></html></div>
<p>This shows the vertices that are in the cycle. The above shown improvement does not give the path of the cycle.</p>
</div>
<div id="node-list" class="section level2">
<h2 class="hasAnchor">
<a href="#node-list" class="anchor"></a>Node List</h2>
<p>The node list shows for each vertex the parent vertices. This is an important representation of a graph, because that is how pedigrees are usually specified. A node list that represents a pedigree has three columns. The first column is used for the ID of the vertex, the second column is used for the first parent vertex (father) and the second column contains the second parent vertex (mother). This change has an impact on the way how neighbors are determined.</p>
<p>Our example graph from above can be specified as a pedigree-node-list given by the following table.</p>
<div class="sourceCode" id="cb26"><html><body><pre class="r"><span class="no">tbl_node_list</span> <span class="kw">&lt;-</span> <span class="kw pkg">tibble</span><span class="kw ns">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span>(<span class="kw">ID</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">1</span>:<span class="fl">6</span>),
                                <span class="kw">Father</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">4</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">6</span>,<span class="fl">4</span>,<span class="fl">5</span>),
                                <span class="kw">Mother</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">NA</span>,<span class="fl">NA</span>,<span class="fl">2</span>,<span class="fl">NA</span>,<span class="fl">NA</span>,<span class="fl">NA</span>))
<span class="kw pkg">knitr</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span>(<span class="no">tbl_node_list</span>)</pre></body></html></div>
<table class="table">
<thead><tr class="header">
<th align="right">ID</th>
<th align="right">Father</th>
<th align="right">Mother</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">4</td>
<td align="right">NA</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">6</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">4</td>
<td align="right">NA</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">5</td>
<td align="right">NA</td>
</tr>
</tbody>
</table>
<p>The function to find the neighbors based on the node list is given below.</p>
<div class="sourceCode" id="cb27"><html><body><pre class="r"><span class="no">get_neighbors_node_list</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">pn_current_vertex</span>, <span class="no">ptbl_node_list</span>) {
  <span class="co"># neighbor vertices can be found in the ID-column of ptbl_node_list where </span>
  <span class="co">#  pn_current_vertex is either in the Father column or the Mother column</span>
  <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">pn_current_vertex</span>, <span class="no">ptbl_node_list</span>$<span class="no">Father</span>)) {
    <span class="no">tbl_result_neighbor</span> <span class="kw">&lt;-</span> <span class="kw pkg">dplyr</span><span class="kw ns">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span>(<span class="no">ptbl_node_list</span>, <span class="no">Father</span> <span class="kw">==</span> <span class="no">pn_current_vertex</span>)
    <span class="no">vec_result_neighbor</span> <span class="kw">&lt;-</span> <span class="no">tbl_result_neighbor</span>$<span class="no">ID</span>
  } <span class="kw">else</span> <span class="kw">if</span> (<span class="fu"><a href="https://rdrr.io/r/base/sets.html">is.element</a></span>(<span class="no">pn_current_vertex</span>, <span class="no">ptbl_node_list</span>$<span class="no">Mother</span>)) {
    <span class="no">tbl_result_neighbor</span> <span class="kw">&lt;-</span> <span class="kw pkg">dplyr</span><span class="kw ns">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span>(<span class="no">ptbl_node_list</span>, <span class="no">Mother</span> <span class="kw">==</span> <span class="no">pn_current_vertex</span>)
    <span class="no">vec_result_neighbor</span> <span class="kw">&lt;-</span> <span class="no">tbl_result_neighbor</span>$<span class="no">ID</span>
  } <span class="kw">else</span> {
    <span class="no">vec_result_neighbor</span> <span class="kw">&lt;-</span> <span class="kw">NULL</span>
  }
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="no">vec_result_neighbor</span>)
}</pre></body></html></div>
<p>The function is tested with</p>
<div class="sourceCode" id="cb28"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span>(<span class="fl">1</span>:<span class="no">nr_vert</span>, <span class="no">get_neighbors_node_list</span>, <span class="no">tbl_node_list</span>)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 2 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 1 5</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; [1] 4</span></pre></body></html></div>
</div>
<div id="reduced-white-set" class="section level2">
<h2 class="hasAnchor">
<a href="#reduced-white-set" class="anchor"></a>Reduced White Set</h2>
<p>Because root-vertices and terminal vertices cannot be elements of a cycle. Any vertex that is an element in a cycle must have at least one edge that points to the vertex and one edge that points away from the vertex, otherwise the cycle would be broken at this vertex. Hence root-vertices and terminal vertices need not be included in the white set. This reduces the number of vertices that must be checked in the DFT-algorithm.</p>
</div>
</div>
<div id="implementation-as-r6-class" class="section level1">
<h1 class="hasAnchor">
<a href="#implementation-as-r6-class" class="anchor"></a>Implementation as R6 Class</h1>
<p>The check for cycles can be implemented using the R6 class-system. The R6 class which does the check is called <code>PedigreeCycleCheck</code>. This class contains the method <code>has_cycle()</code> which does the check as shown in the function <code>has_cycle()</code> above. The advantage of this solution is that information about the pedigree which might be large needs to be stored only once and does not have to be passed as function argument.</p>
<p>The check for the pedigree with a cycle is done as shown below.</p>
<div class="sourceCode" id="cb29"><html><body><pre class="r"><span class="no">pcfc</span> <span class="kw">&lt;-</span> <span class="no">PedigreeCycleCheck</span>$<span class="fu">new</span>()
<span class="no">pcfc</span>$<span class="fu">set_tbl_pedigree</span>(<span class="kw">ptbl_pedigree</span> <span class="kw">=</span> <span class="no">tbl_node_list</span>)
<span class="no">pcfc</span>$<span class="fu">set_n_ani_col</span>(<span class="kw">pn_ani_col</span> <span class="kw">=</span> <span class="fl">1</span>)
<span class="no">pcfc</span>$<span class="fu">set_n_sire_col</span>(<span class="kw">pn_sire_col</span> <span class="kw">=</span> <span class="fl">2</span>)
<span class="no">pcfc</span>$<span class="fu">set_n_dam_col</span>(<span class="kw">pn_dam_col</span> <span class="kw">=</span> <span class="fl">3</span>)
<span class="no">pcfc</span>$<span class="fu">has_cycle</span>()
<span class="co">#&gt; [1] TRUE</span></pre></body></html></div>
<p>The result of the method <code>has_cycle()</code> returns either true or false. If we want to know the vertices that occur in a cycle, they can be obtained via the following statements</p>
<div class="sourceCode" id="cb30"><html><body><pre class="r"><span class="no">pcfc</span>$<span class="fu">set_b_report_cycle</span>(<span class="fl">TRUE</span>)
<span class="no">pcfc</span>$<span class="fu">has_cycle</span>()
<span class="co">#&gt; [1] TRUE</span>
<span class="no">pcfc</span>$<span class="fu">get_tbl_cycle</span>()
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   parent offspring</span>
<span class="co">#&gt;    &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1      4         5</span>
<span class="co">#&gt; 2      5         6</span>
<span class="co">#&gt; 3      6         4</span></pre></body></html></div>
<p>Doing the same check with a pedigree without loop is done as follows.</p>
<div class="sourceCode" id="cb31"><html><body><pre class="r"><span class="no">tbl_ped_no_cycle</span> <span class="kw">&lt;-</span> <span class="kw pkg">tibble</span><span class="kw ns">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span>(<span class="kw">ID</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">1</span>:<span class="fl">6</span>),
                                   <span class="kw">Father</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">4</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">NA</span>,<span class="fl">4</span>,<span class="fl">5</span>),
                                   <span class="kw">Mother</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">NA</span>,<span class="fl">NA</span>,<span class="fl">2</span>,<span class="fl">NA</span>,<span class="fl">NA</span>,<span class="fl">NA</span>))
<span class="no">pcnc</span> <span class="kw">&lt;-</span> <span class="no">PedigreeCycleCheck</span>$<span class="fu">new</span>()
<span class="no">pcnc</span>$<span class="fu">set_tbl_pedigree</span>(<span class="kw">ptbl_pedigree</span> <span class="kw">=</span> <span class="no">tbl_ped_no_cycle</span>)
<span class="no">pcnc</span>$<span class="fu">set_n_ani_col</span>(<span class="kw">pn_ani_col</span> <span class="kw">=</span> <span class="fl">1</span>)
<span class="no">pcnc</span>$<span class="fu">set_n_sire_col</span>(<span class="kw">pn_sire_col</span> <span class="kw">=</span> <span class="fl">2</span>)
<span class="no">pcnc</span>$<span class="fu">set_n_dam_col</span>(<span class="kw">pn_dam_col</span> <span class="kw">=</span> <span class="fl">3</span>)
<span class="no">pcnc</span>$<span class="fu">has_cycle</span>()
<span class="co">#&gt; [1] FALSE</span></pre></body></html></div>
<div id="wrapper-function-for-cycle-check" class="section level2">
<h2 class="hasAnchor">
<a href="#wrapper-function-for-cycle-check" class="anchor"></a>Wrapper Function for Cycle Check</h2>
<p>Working with the R6 objects is not easy. To simplify, a wrapper function is available. This is used as shown below.</p>
<div class="sourceCode" id="cb32"><html><body><pre class="r"><span class="fu"><a href="../reference/check_cycle_pedigree.html">check_cycle_pedigree</a></span>(<span class="kw">ptbl_pedigree</span> <span class="kw">=</span> <span class="no">tbl_node_list</span>, <span class="kw">pb_report_cycle</span> <span class="kw">=</span> <span class="fl">TRUE</span>)
<span class="co">#&gt; $PedFile</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $HasCycle</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $TblCycle</span>
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   parent offspring</span>
<span class="co">#&gt;    &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1      4         5</span>
<span class="co">#&gt; 2      5         6</span>
<span class="co">#&gt; 3      6         4</span></pre></body></html></div>
<p>The wrapper function can also be used with a pedigree that is read from an input file.</p>
<div class="sourceCode" id="cb33"><html><body><pre class="r"><span class="fu"><a href="../reference/check_cycle_pedigree.html">check_cycle_pedigree</a></span>(<span class="kw">ps_pedig_path</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span>(<span class="st">'extdata'</span>,<span class="st">'data_sample2.csv'</span>, <span class="kw">package</span> <span class="kw">=</span> <span class="st">'qpdt'</span>))
<span class="co">#&gt; $PedFile</span>
<span class="co">#&gt; [1] "/private/var/folders/2v/jfsqj8zj2f122jcgy15nzfn00000gn/T/Rtmp4wSii3/temp_libpath909f297b1eee/qpdt/extdata/data_sample2.csv"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $HasCycle</span>
<span class="co">#&gt; [1] FALSE</span></pre></body></html></div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Peter von Rohr.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
