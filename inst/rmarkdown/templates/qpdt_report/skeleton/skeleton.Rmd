---
title: Pedigree Check Report For `r params$pedigreeName`
date: "`r Sys.Date()`"
author: "`r params$reportAuthor`"
output: html_document
params:
  pedigreePath:
    label: "Path To Pedigree Input File"
    value: ""
  pedigreeName:
    label: "Pedigree Name"
    value: ""
  pedigreeType:
    label: "Pedigree Type"
    value: "generic"  
    choices: ["generic", "gnm", "argus"]
  reportAuthor:
    label: "Report Author"
    value: ""
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r parameter-settings, echo=FALSE}
# parameter settings for current pedigree
if (params$pedigreeType == 'gnm'){
  l_settings <- qpdt::get_gnm_prp_settings()  
} else if (params$pedigreeType == 'argus'){
  l_settings <- qpdt::get_argus_prp_settings()
} else {
  l_settings <- qpdt::get_generic_settings()
}
# initialise variables that influence the inculsion of junks
nr_sire_incon_bd <- 0
nr_dam_incon_bd <- 0
nr_sire_eqid <- 0
nr_dam_eqid <- 0
nr_sire_wrongsex <- 0
nr_dam_wrongsex <- 0
```

# Disclaimer
This document contains the report for the pedigree: __`r params$pedigreeName`__. The report is generated by the function `qpdt::create_report()`. The report should show potential problems with the input pedigrees.


# General Properties
It is assumed that the pedigree to be checked in this report is given by a tabular representation. Each row in the table specifies for each animal the available information, such as sire, dam, date of birth and further information.  

Animals in a pedigree must be identified by unique identifiers. These identifiers are also used to assign parents to animals. The check for the uniqueness of the identifiers yields the following result.

```{r id-check, echo=FALSE, message=FALSE, warning=FALSE}
l_pedig_id_result <- qpdt::check_pedig_id(ps_pedig_path = params$pedigreePath, 
                                          ps_id_col     = l_settings$id_col,
                                          ps_delim      = l_settings$col_delim)
```

The currently checked pedigree is imported from: `r l_pedig_id_result$PedFile`. 

The results of the uniqueness check of the identifiers is shown in the table below.

```{r tbl-uni-id, echo=FALSE, message=FALSE, warning=FALSE}
n_nr_dupl <- ifelse(is.null(l_pedig_id_result$TblDuplicates), 0, nrow(l_pedig_id_result$TblDuplicates))
tbl_uni_id <- tibble::tibble(Property = c('Number of records',
                                          'Number of animals',
                                          'Number of duplicate IDs'),
                             Value    = c(l_pedig_id_result$NrRecord,
                                          l_pedig_id_result$NrAnimals,
                                          n_nr_dupl))
knitr::kable(tbl_uni_id)
```

In case the above check found some duplicate identifiers, they are shown in the table below.

```{r echo=FALSE, include=(n_nr_dupl > 0)}
 knitr::kable(l_pedig_id_result$TblDuplicates)
```


# Data Types
Entries in the same column must all be of a certain data type. The data type can either be specified at reading time or it is automatically determined when reading the pedigree from the file. The determined data types are then compared to the required data types specified as input. The following table compares the required data types to the data types found in the input file.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# get the results for the data type check
l_dtp_check_result <- qpdt::check_pedigree_datatypes(ps_pedig_path = params$pedigreePath, pl_dtype = l_settings$l_dtype)
# number of data type mismatches
n_nr_mismatch <- sum(l_dtp_check_result$ReqDType$dtp != l_dtp_check_result$CurDType$dtp)
# get the number of parse problems
n_nr_parse_problem <- ifelse(is.null(l_dtp_check_result$DTypeProblems), 0, nrow(l_dtp_check_result$DTypeProblems))
# create table with comparison of data types
tbl_datatypes <- tibble::tibble(Column = l_settings$l_dtype$col,
                                `Required Data Type` = l_settings$l_dtype$dtp,
                                `Found Data Type`    = l_dtp_check_result$CurDType$dtp)
knitr::kable(tbl_datatypes)
```

The comparison between the required and the number of found data types resulted in __`r paste0(n_nr_mismatch, ' mismatch', ifelse(n_nr_mismath != 1, 'es', ''), collapse = '')`__. `r if(n_nr_mismath > 0) "In case where mismatches could be found, the respective parse problems are shown in the table below."`

```{r, echo=FALSE, results='asis', include=(n_nr_parse_problem == 0)}
cat("\n<!--\n")
```

## Pedigree Input Parse Problems
The following table shows problems when parsing the pedigree input file.

```{r echo=FALSE}
knitr::kable(l_dtp_check_result$DTypeProblems)
```

## Note
In case the above table shows problems with parsing the given pedigree input file, then all subsequent R-code junks cannot be evaluated and the ouput of the rest of the report is suppressed. To see the remainer of the report, the parsing problems must be fixed first.  

```{r, echo=FALSE, results='asis', include=(n_nr_parse_problem == 0)}
cat("\n-->\n\n")
```

```{r echo=FALSE, results='asis', include=(n_nr_parse_problem != 0)}
# in case where parse problems were found, the following junks can no longer be evaluated
knitr::opts_chunk$set(eval = (n_nr_parse_problem == 0))
cat('\n<!--\n\n')
```


# Parents
Parents of animals must fullfill certain properties. The following properties are checked

* number of animals without parents
* number of parents which do not appear as animals
* number of parents with inconsistent birthdates
* number of parents that have the same ID as their offspring
* number of parents which have the wrong sex

The following table shows the numbers of all the checked properties.

```{r parent-check, echo=FALSE, message=FALSE, warning=FALSE}
l_parent_result <- qpdt::check_pedig_parent(ps_pedig_path = params$pedigreePath,
                                            ps_id_col        = l_settings$id_col,
                                            ps_sire_col      = l_settings$sire_col,
                                            ps_dam_col       = l_settings$dam_col,
                                            ps_bd_col        = l_settings$bd_col,
                                            ps_sex_col       = l_settings$sex_col)
# number of inconsistent birthdates
nr_sire_incon_bd <- nrow(l_parent_result$TblSireBdate)
nr_dam_incon_bd <- nrow(l_parent_result$TblDamBdate)
# number of equal ids between parents and animals
nr_sire_eqid <- nrow(l_parent_result$TblSireEqID)
nr_dam_eqid <- nrow(l_parent_result$TblDamEqID)
# number of parents with wrong sex
nr_sire_wrongsex <- nrow(l_parent_result$TblSireWrongSex)
nr_dam_wrongsex <- nrow(l_parent_result$TblDamWrongSex)
tbl_parent_result <- tibble::tibble(Property = c('Animals with missing sires',
                                                 'Animals with missing dams',
                                                 'Sires not occuring as animals',
                                                 'Dams not occurding as animals',
                                                 'Sires with inconsistent birthdates',
                                                 'Dams with inconsistent birthdates',
                                                 'Sires with same ID as offspring',
                                                 'Dams with same ID as offspring',
                                                 'Sires with wrong sex',
                                                 'Dams with wrong sex'),
                                    `Count Values` = c(l_parent_result$NrMissingSire,
                                                       l_parent_result$NrMissingDam,
                                                       l_parent_result$NrSireNotAnimal,
                                                       l_parent_result$NrDamNotAnimal,
                                                       nr_sire_incon_bd,
                                                       nr_dam_incon_bd,
                                                       nr_sire_eqid,
                                                       nr_dam_eqid,
                                                       nr_sire_wrongsex,
                                                       nr_dam_wrongsex))
knitr::kable(tbl_parent_result)
```

In case that there are pedigree records with inconsistent information concerning parents of animals, the respective records are shown in the table below.

```{r, echo=FALSE, results='asis', include=(nr_sire_incon_bd == 0)}
# number of inconsistent birthdates with sires
cat("\n<!--\n")
```

## Inconsistent Birthdates for Sires
The records with inconsistent birthdates between animals and __sires__ are shown in the table below.

```{r echo=FALSE}
knitr::kable(l_parent_result$TblSireBdate)
```

```{r, echo=FALSE, results='asis', include=(nr_sire_incon_bd == 0)}
cat("\n-->\n\n")
```


```{r, echo=FALSE, results='asis', include=(nr_dam_incon_bd == 0)}
# number of inconsistent birthdates with dams
cat("\n<!--\n")
```

## Inconsistent Birthdates for Dams
The records with inconsistent birthdates between animals and __dams__ are shown in the table below.

```{r echo=FALSE}
knitr::kable(l_parent_result$TblDamBdate)
```

```{r, echo=FALSE, results='asis', include=(nr_dam_incon_bd == 0)}
cat("\n-->\n\n")
```

```{r, echo=FALSE, results='asis', include=(nr_sire_eqid == 0)}
# number of equal ids between sire and animals
cat("\n<!--\n")
```

## Inconsistent IDs of Sires and Offspring
The following animals have the same ID as their __sires__.

```{r, echo=FALSE}
knitr::kable(l_parent_result$TblSireEqID)
```

```{r, echo=FALSE, results='asis', include=(nr_sire_eqid == 0)}
cat("\n-->\n\n")
```

```{r, echo=FALSE, results='asis', include=(nr_dam_eqid == 0)}
# number of equal ids between dam and animals
cat("\n<!--\n")
```

## Inconsistent IDs of Dams and Offspring
The following animals have the same ID as their __dams__.

```{r, echo=FALSE}
knitr::kable(l_parent_result$TblDamEqID)
```

```{r, echo=FALSE, results='asis', include=(nr_dam_eqid == 0)}
cat("\n-->\n\n")
```

```{r, echo=FALSE, results='asis', include=(nr_sire_wrongsex == 0)}
# number sires with wrong sex
cat("\n<!--\n")
```

## Sires with wrong sex
The following __sires__ have the wrong sex.

```{r, echo=FALSE}
knitr::kable(l_parent_result$TblSireWrongSex)
```

```{r, echo=FALSE, results='asis', include=(nr_sire_wrongsex == 0)}
cat("\n-->\n\n")
```

```{r, echo=FALSE, results='asis', include=(nr_dam_wrongsex == 0)}
# number dams with wrong sex
cat("\n<!--\n")
```

## Dams with wrong sex
The following __dams__ have the wrong sex.

```{r, echo=FALSE}
knitr::kable(l_parent_result$TblDamWrongSex)
```

```{r, echo=FALSE, results='asis', include=(nr_dam_wrongsex == 0)}
cat("\n-->\n\n")
```

```{r, eval=TRUE, echo=FALSE, results='asis', include=(n_nr_parse_problem != 0)}
cat("\n -->\n\n")
```


```{r latest-change, eval=TRUE, echo=FALSE, results='asis'}
cat("\n\n---\n", "_Latest Changes: ", format(Sys.time(), format = "%Y-%m-%d %H:%M:%S"), " (", Sys.info()[['user']], ")_")
```

